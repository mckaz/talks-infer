Class,Method Name,Arg/Ret/Var,Variable Name,Inferred Type,Original Type,Exact (E) / Up to Parameter (P) / Got Type (T) / None (N),Solution Source,Source Code
User,name_and_email,Ret,"",String,String,E,Constraints,"def name_and_email
    ""#{name} &lt;#{email}&gt;"".sanitize
  end"
User,email_and_name,Ret,"",String,String,E,Constraints,"def email_and_name
    ""#{email} (#{name})"".sanitize
  end"
User,subscribed_lists,Ret,"","Array<[List, String]>",Array<Array<(List or Symbol)>>,P,Constraints,"def subscribed_lists
    subscriptions.where(:subscribable_type => ""List"").map { |s| [List.find(s.subscribable_id), s.kind] }
  end"
User,subscribed_talks,Arg,range,([ ==: (:all) -> (false or true) ] and [ ==: (:current) -> (false or true) ] and [ ==: (:past) -> (false or true) ] and [ ==: (:this_week) -> (false or true) ] and [ ==: (:today) -> (false or true) ] and [ ==: (:upcoming) -> (false or true) ] and [ inspect: () -> { { User#subscribed_talks arg: range }#inspect call_ret: ret } ]),Symbol,TS,Constraints,"def subscribed_talks(range, filter = [""kind_subscriber"", ""kind_subscriber_through"", ""kind_watcher"", ""kind_watcher_through""])
    raise ""Argument #{range.inspect} out of range"" unless [:past, :today, :this_week, :upcoming, :current, :all].member? range
    talks = {} # map from talk to kind

    # directly subscribed talks
    subscriptions
      .where(:subscribable_type => ""Talk"")
      .map do |s|
        t = Talk.find(s.subscribable_id)
        talks[t] = s.kind if (t.match_range range) && (filter.member? s.kind)
      end

    # subscriptions via lists, whicih take precedence over directly subscribing/watching
    subscribed_lists.each do |l,k|
      l.talks.each do |t|
        if t.match_range range then
          case k
          when ""kind_subscriber""
            talks[t] = ""kind_subscriber_through"" if filter.member? ""kind_subscriber_through""
          when ""kind_watcher""
            talks[t] = ""kind_watcher_through"" if (talks[t] != ""kind_subscriber"") && (filter.member? ""kind_watcher_through"")
          end
        end
      end
    end

    return talks
  end"
User,subscribed_talks,Ret,"","Hash<Talk, String>","Hash<Talk, (String or Symbol)>",P,Constraints,"def subscribed_talks(range, filter = [""kind_subscriber"", ""kind_subscriber_through"", ""kind_watcher"", ""kind_watcher_through""])
    raise ""Argument #{range.inspect} out of range"" unless [:past, :today, :this_week, :upcoming, :current, :all].member? range
    talks = {} # map from talk to kind

    # directly subscribed talks
    subscriptions
      .where(:subscribable_type => ""Talk"")
      .map do |s|
        t = Talk.find(s.subscribable_id)
        talks[t] = s.kind if (t.match_range range) && (filter.member? s.kind)
      end

    # subscriptions via lists, whicih take precedence over directly subscribing/watching
    subscribed_lists.each do |l,k|
      l.talks.each do |t|
        if t.match_range range then
          case k
          when ""kind_subscriber""
            talks[t] = ""kind_subscriber_through"" if filter.member? ""kind_subscriber_through""
          when ""kind_watcher""
            talks[t] = ""kind_watcher_through"" if (talks[t] != ""kind_subscriber"") && (filter.member? ""kind_watcher_through"")
          end
        end
      end
    end

    return talks
  end"
Talk,extended_title,Ret,"",String,String,E,Constraints,"def extended_title
    if kind == :standard
      title
    else
      ""#{kind_text}: #{title}""
    end
  end"
Talk,start_end_same_day,Ret,"",Array<String>,Array<String>,E,Constraints,"def start_end_same_day
    if start_time && end_time && (start_time.to_date != end_time.to_date)
      errors.add(:internal_error, ""- start time and end time must be on same day"")
    end
  end"
Talk,start_end_not_error,Ret,"",Array<String>,Array<String>,E,Constraints,"def start_end_not_error
    errors.add(:start_time, ""- Invalid start time"") if not start_time
    errors.add(:end_time, ""- Invalid end time"") if not end_time
  end"
Talk,start_less_than_end,Ret,"",Array<String>,Array<String>,E,Constraints,"def start_less_than_end
    errors.add(:end_time, ""- End time must be greater than start time"") if (start_time && end_time && (not (end_time > start_time)))
  end"
Talk,at_least_one_list,Ret,"",Array<String>,Array<String>,E,Constraints,"def at_least_one_list
    errors[:base] << ""A talk must belong to at least one list"" if lists.length < 1
  end"
[s]Talk,upcoming,Ret,"",ActiveRecord_Relation<Talk>,ActiveRecord_Relation<Talk>,E,Constraints,"def self.upcoming
    # use end_time so talks going on now still appear
    where(""end_time >= ?"", Time.zone.now)
  end"
[s]Talk,past,Ret,"",ActiveRecord_Relation<Talk>,ActiveRecord_Relation<Talk>,E,Constraints,"def self.past
    where(""end_time < ? and end_time >= ?"", Time.zone.now.beginning_of_day, Time.zone.now - 1.year)
  end"
[s]Talk,current,Ret,"",ActiveRecord_Relation<Talk>,ActiveRecord_Relation<Talk>,E,Constraints,"def self.current
    where(""end_time >= ?"", Time.zone.now.beginning_of_day)
  end"
[s]Talk,today,Ret,"",ActiveRecord_Relation<Talk>,ActiveRecord_Relation<Talk>,E,Constraints,"def self.today
    where(""end_time >= ? and start_time < ?"", Time.zone.now.beginning_of_day, Time.zone.now.end_of_day)
  end"
[s]Talk,this_week,Ret,"",ActiveRecord_Relation<Talk>,ActiveRecord_Relation<Talk>,E,Constraints,"def self.this_week
    where(""end_time >= ? and start_time < ?"", (Time.zone.now + 1.day).beginning_of_week - 1.day, (Time.zone.now + 1.day).end_of_week - 1.day)
  end"
Talk,past?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def past?
    end_time < Time.zone.now.beginning_of_day
  end"
Talk,upcoming?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def upcoming?
    end_time >= Time.zone.now
  end"
Talk,current?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def current?
    (end_time >= Time.zone.now.beginning_of_day)
  end"
Talk,today?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def today?
    (end_time >= Time.zone.now.beginning_of_day) && (start_time < Time.zone.now.end_of_day)
  end"
Talk,this_week?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def this_week?
    (end_time >= (Time.zone.now + 1.day).beginning_of_week - 1.day) && (start_time < (Time.zone.now + 1.day).end_of_week - 1.day)
  end"
Talk,later_this_week?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def later_this_week?
    (not past?) && (end_time >= (Time.zone.now + 1.day).beginning_of_week - 1.day) && (start_time < (Time.zone.now + 1.day).end_of_week - 1.day)
  end"
Talk,next_week?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def next_week?
    (end_time >= (Time.zone.now + 1.day).beginning_of_week + 6.day) && (start_time < (Time.zone.now + 1.day).end_of_week + 6.day)
  end"
Talk,further_ahead?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def further_ahead?
    (end_time >= (Time.zone.now + 1.day).beginning_of_week + 13.day)
  end"
Talk,match_range,Arg,range,([ ==: (:all) -> (false or true) ] and [ ==: (:current) -> (false or true) ] and [ ==: (:past) -> (false or true) ] and [ ==: (:this_week) -> (false or true) ] and [ ==: (:today) -> (false or true) ] and [ ==: (:upcoming) -> (false or true) ]),Symbol,TS,Constraints,"def match_range(range)
    (range == :all) ||
      (range == :past && past?) ||
      (range == :upcoming && upcoming?) ||
      (range == :current && current?) ||
      (range == :today && today?) ||
      (range == :this_week && this_week?)
  end"
Talk,match_range,Ret,"",(false or true),(false or true),E,Constraints,"def match_range(range)
    (range == :all) ||
      (range == :past && past?) ||
      (range == :upcoming && upcoming?) ||
      (range == :current && current?) ||
      (range == :today && today?) ||
      (range == :this_week && this_week?)
  end"
Talk,owner?,Arg,user,User,User,E,Heur: is_model,"def owner?(user)
    return owner == user
  end"
Talk,owner?,Ret,"",(false or true),(false or true),E,Constraints,"def owner?(user)
    return owner == user
  end"
Talk,poster?,Arg,user,User,User,E,Heur: is_model,"def poster?(user)
    return false
  end"
Talk,poster?,Ret,"",(false or true),(false or true),E,Constraints,"def poster?(user)
    return false
  end"
Talk,subscriber?,Arg,user,User,User,E,Heur: is_model,"def subscriber?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_subscriber"")
  end"
Talk,subscriber?,Ret,"",(false or true),(false or true),E,Constraints,"def subscriber?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_subscriber"")
  end"
Talk,watcher?,Arg,user,User,User,E,Heur: is_model,"def watcher?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_watcher"")
  end"
Talk,watcher?,Ret,"",(false or true),(false or true),E,Constraints,"def watcher?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_watcher"")
  end"
Talk,registered?,Arg,user,User,User,E,Heur: is_model,"def registered?(user)
    not (registrations.where(:user_id => user.id).empty?)
  end"
Talk,registered?,Ret,"",(false or true),(false or true),E,Constraints,"def registered?(user)
    not (registrations.where(:user_id => user.id).empty?)
  end"
Talk,through,Arg,user,User,User,E,Heur: is_model,"def through(user)
    h = Hash.new RDL.type_cast([], ""Array<List>"")
    return h unless user
    user.subscribed_lists.each do |l, kl|
      if l.talks.exists? self.id then
        if kl == ""kind_subscriber""
          h[:subscriber] += [l]
        elsif kl == ""kind_watcher""
          h[:watcher] += [l]
        end
      end
    end
    return h
  end"
Talk,through,Ret,"","{ subscriber: Array<(List or { { { Talk#through arg: user }#subscribed_lists call_ret: ret }#each block_arg: l })>, watcher: Array<(List or { { { Talk#through arg: user }#subscribed_lists call_ret: ret }#each block_arg: l })> }",(:kind_subscriber_through or :kind_watcher_through),T,Constraints,"def through(user)
    h = Hash.new RDL.type_cast([], ""Array<List>"")
    return h unless user
    user.subscribed_lists.each do |l, kl|
      if l.talks.exists? self.id then
        if kl == ""kind_subscriber""
          h[:subscriber] += [l]
        elsif kl == ""kind_watcher""
          h[:watcher] += [l]
        end
      end
    end
    return h
  end"
Talk,email_watchers,Arg,changes,(ActiveRecord_Relation<Talk> or Array<Talk>),Set<(:abstract or :bio or :reg or :speaker or :time or :title or :venue)>,T,Twin,"def email_watchers(changes)
    to_email = []
    to_email += subscribers # all direct subscribers
    to_email += RDL.type_cast((lists.map { |l| l.subscribers }).flatten, ""Array<User>"") # all indirect subscribers

    to_email.uniq.each do |u|
      TheMailer.send_talk_change(u, self, changes).deliver_now
    end
  end"
Talk,email_watchers,Ret,"",Array<(User or { Talk#email_watchers array_param: array_param_#<Parser::Source::Map::Collection:0x00007f997c8bc578> })>,Array<User>,P,Constraints,"def email_watchers(changes)
    to_email = []
    to_email += subscribers # all direct subscribers
    to_email += RDL.type_cast((lists.map { |l| l.subscribers }).flatten, ""Array<User>"") # all indirect subscribers

    to_email.uniq.each do |u|
      TheMailer.send_talk_change(u, self, changes).deliver_now
    end
  end"
Building,abbrv_and_name,Ret,"",String,String,E,Constraints,"def abbrv_and_name
    return abbrv if name == """" || name.nil?
    return ""#{abbrv} - #{name}""
  end"
List,subscription,Arg,user,User,User,E,Heur: is_model,"def subscription(user)
    s = Subscription.where(:subscribable_id => id, :subscribable_type => ""List"", :user_id => user.id)
    return nil if s.length == 0
    return s.first if s.length == 1
    logger.error ""Multiple subscriptions #{s}""
    return nil
  end"
List,subscription,Ret,"",Subscription,Subscription,E,Constraints,"def subscription(user)
    s = Subscription.where(:subscribable_id => id, :subscribable_type => ""List"", :user_id => user.id)
    return nil if s.length == 0
    return s.first if s.length == 1
    logger.error ""Multiple subscriptions #{s}""
    return nil
  end"
List,owner?,Arg,user,User,User,E,Heur: is_model,"def owner?(user)
    return owners.include? user
  end"
List,owner?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def owner?(user)
    return owners.include? user
  end"
List,poster?,Arg,user,User,User,E,Heur: is_model,"def poster?(user)
    return posters.include? user
  end"
List,poster?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def poster?(user)
    return posters.include? user
  end"
List,watcher?,Arg,user,User,User,E,Constraints,"def watcher?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_watcher"")
  end"
List,watcher?,Ret,"",{ List#watcher? ret: ret },(false or true),N,Constraints,"def watcher?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_watcher"")
  end"
List,subscriber?,Arg,user,User,User,E,Constraints,"def subscriber?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_subscriber"")
  end"
List,subscriber?,Ret,"",{ List#subscriber? ret: ret },(false or true),N,Constraints,"def subscriber?(user)
    s = subscription(user)
    return s && (s.kind == ""kind_subscriber"")
  end"
AdminController,index,Ret,"",Array<Talk>,nil,T,Twin,"def index
  end"
AdminController,spam,Ret,"",Array<Talk>,nil,T,Twin,"def spam
  end"
AdminController,send_spam,Ret,"",String,String,E,Constraints,"def send_spam
#    AdminController.delay.spam_users(:subject => params[:subject], :message => params[:message])
    redirect_to admin_index_path, :notice => ""Sending message to all users...""
  end"
[s]AdminController,spam_users,Arg,h,"{ message: { { TheMailer#send_admin_message arg: h }#[] call_ret: ret }, subject: String }","Hash<Symbol, String>",P,Heur: hash_access,"def self.spam_users(h)
    User.all.each do |u|
      if u.confirmed_at
        TheMailer.send_admin_message(u, h).deliver_now
      end
    end
    logger.debug ""Messages delivered.""
  end"
[s]AdminController,spam_users,Ret,"",(false or true),(false or true),E,Constraints,"def self.spam_users(h)
    User.all.each do |u|
      if u.confirmed_at
        TheMailer.send_admin_message(u, h).deliver_now
      end
    end
    logger.debug ""Messages delivered.""
  end"
ApplicationController,require_site_admin,Ret,"",ActiveRecord_Relation<Talk>,%any,E,Twin,"def require_site_admin
    authorize! :site_admin, :all
  end"
ApplicationController,generate_ical,Arg,talks,(ActiveRecord_Relation<Talk> or Array<Talk>),Array<Talk>,P,Heur: is_pluralized_model,"def generate_ical(talks)
    coder = HTMLEntities.new
    cal = RiCal.Calendar do |cal|
      talks.each do |t|
        cal.event do |event|
          event.summary = ""#{t.speaker} - #{t.title}""
          event.dtstart = t.start_time.in_time_zone(""US/Eastern"")
          event.dtend = t.end_time.in_time_zone(""US/Eastern"")
          if t.room && t.building
            event.location = ""#{t.room} #{t.building.abbrv}""
          elsif t.room
            event.location = t.room
          end
	        event.url = talk_url(t)
          # notes = """"
          # unless t.abstract.empty?
	        #    notes = coder.decode(ActionController::Base.helpers.strip_tags(t.abstract))
          # else
	        #    notes = ""(No abstract yet)""
	        # end
	        # unless t.bio.empty?
	        #    notes << ""Bio: "" << coder.decode(ActionController::Base.helpers.strip_tags(t.bio))
	        # end
	        # event.description = notes
        end
      end
    end
  end"
ApplicationController,generate_ical,Ret,"",(false or true),RiCal::Component::Calendar,T,Twin,"def generate_ical(talks)
    coder = HTMLEntities.new
    cal = RiCal.Calendar do |cal|
      talks.each do |t|
        cal.event do |event|
          event.summary = ""#{t.speaker} - #{t.title}""
          event.dtstart = t.start_time.in_time_zone(""US/Eastern"")
          event.dtend = t.end_time.in_time_zone(""US/Eastern"")
          if t.room && t.building
            event.location = ""#{t.room} #{t.building.abbrv}""
          elsif t.room
            event.location = t.room
          end
	        event.url = talk_url(t)
          # notes = """"
          # unless t.abstract.empty?
	        #    notes = coder.decode(ActionController::Base.helpers.strip_tags(t.abstract))
          # else
	        #    notes = ""(No abstract yet)""
	        # end
	        # unless t.bio.empty?
	        #    notes << ""Bio: "" << coder.decode(ActionController::Base.helpers.strip_tags(t.bio))
	        # end
	        # event.description = notes
        end
      end
    end
  end"
ApplicationController,fix_range,Arg,params,"([ []: (:range) -> { { ApplicationController#fix_range arg: params }#[] call_ret: ret } ] and [ []=: (:range, :current) -> { { ApplicationController#fix_range arg: params }#[]= call_ret: ret } ])","Hash<(String or Symbol), %any>",TS,Constraints,"def fix_range(params)
    params[:range] = :current unless params[:range]
    params[:range] = params[:range].to_sym
  end"
ApplicationController,fix_range,Ret,"",Array<String>,Symbol,T,Twin,"def fix_range(params)
    params[:range] = :current unless params[:range]
    params[:range] = params[:range].to_sym
  end"
BuildingsController,@buildings,Var,@buildings,Array<Building>,Array<Building>,E,Constraints,""
BuildingsController,index,Ret,"",Array<Building>,Array<Building>,E,Constraints,"def index
    authorize! :edit_buildings, :all
    @buildings = Building.all.sort { |a, b| a.abbrv <=> b.abbrv }
  end"
BuildingsController,update,Ret,"",String,(Array<String> or String),T,Constraints,"def update
    authorize! :edit_buildings, :all
    msg = """"
    if (params[:building_abbrv_new] != """") || (params[:building_name_new] != """") || (params[:building_url_new] != nil)
      logger.info "">> #{params[:building_abbrv_new].inspect}, #{params[:building_name_new].inspect}, #{params[:building_url_new].inspect}""
      b = Building.new(:abbrv => params[:building_abbrv_new],
                          :name => params[:building_name_new],
                          :url => params[:building_url_new])
      b.save
      msg << ""New building: "" << b.errors.full_messages.join("" "") << ""<br/>"" if not (b.errors.empty?)
    end
    params.each_pair do |k,v|
      next unless k =~ /^building_(.*)_(\d+)/
      b = Building.find($2)
      case $1
      when ""abbrv"", ""name"", ""url"" # only valid attrs
        next if b.send($1) == v   # unchanged
        old_abbrv = b.abbrv
        b.send(""#{$1}="", v)       # set value
        b.save
        msg << ""#{old_abbrv}: "" + b.errors.full_messages.join("" "") << ""<br/>"" if not (b.errors.empty?)
      else
        next
      end
    end
    redirect_to buildings_index_path, :alert => msg.sanitize
  end"
BuildingsController,destroy,Ret,"",String,String,E,Constraints,"def destroy
    authorize! :edit_buildings, :all
    b = Building.find(params[:id])
    abbrv = b.abbrv
    b.destroy
    redirect_to buildings_index_path, :alert => ""Building #{abbrv} deleted""
  end"
JobsController,@jobs,Var,@jobs,Array<Delayed::Backend::ActiveRecord::Job>,Array<Delayed::Job>,P,Constraints,""
JobsController,index,Ret,"",Array<Delayed::Backend::ActiveRecord::Job>,Array<Delayed::Job>,P,Constraints,"def index
    @jobs = Delayed::Job.all.sort { |a,b| a.created_at <=> b.created_at }
  end"
JobsController,@job,Var,@job,Delayed::Backend::ActiveRecord::Job,Delayed::Job,T,Constraints,""
JobsController,delete,Ret,"",String,String,E,Constraints,"def delete
    @job = Delayed::Job.find(params[:id])
    tm = @job.created_at
    @job.destroy
    flash[:notice] = ""Deleted job that was created at #{tm}""

    redirect_to jobs_index_path
  end"
JobsController,delete_all,Ret,"",String,String,E,Constraints,"def delete_all
    Delayed::Job.all.each { |j|
      j.destroy
    }
    flash[:notice] = ""Deleted all jobs""

    redirect_to jobs_index_path
  end"
JobsController,@out,Var,@out,String,String,E,Constraints,""
JobsController,do_start,Ret,"",String,String,E,Constraints,"def do_start
    runcmd ""#{::Rails.root}/script/delayed_job restart""
    flash[:notice] = @out.sanitize
    redirect_to jobs_index_path
  end"
JobsController,do_stop,Ret,"",String,String,E,Constraints,"def do_stop
    runcmd ""#{::Rails.root}/script/delayed_job stop""
    flash[:notice] = @out.sanitize
    redirect_to jobs_index_path
  end"
JobsController,do_restart,Ret,"",String,String,E,Constraints,"def do_restart
    runcmd ""#{::Rails.root}/script/delayed_job restart""
    flash[:notice] = @out.sanitize
    redirect_to jobs_index_path
  end"
JobsController,do_reload,Ret,"",String,String,E,Constraints,"def do_reload
    runcmd ""#{::Rails.root}/script/delayed_job reload""
    flash[:notice] = @out.sanitize
    redirect_to jobs_index_path
  end"
JobsController,do_status,Ret,"",String,String,E,Constraints,"def do_status
    runcmd ""#{::Rails.root}/script/delayed_job status""
    flash[:notice] = @out.sanitize
    redirect_to jobs_index_path
  end"
JobsController,@success,Var,@success,(false or true),(false or true),E,Constraints,""
JobsController,runcmd,Arg,cmd,{ JobsController#runcmd arg: cmd },String,N,,"def runcmd(cmd)
    @out = """" if not @out
    @success = true if @success == nil
    @out << ""<span class=\""command\"">shell$ #{cmd}</span><br/>""
    res = `#{cmd} 2>&1`
    @out << res.gsub(""\n"", ""<br/>"")
    if $?.exitstatus != 0 then
      error ""Command returned #{$?.exitstatus}""
    end
    res
  end"
JobsController,runcmd,Ret,"",String,String,E,Constraints,"def runcmd(cmd)
    @out = """" if not @out
    @success = true if @success == nil
    @out << ""<span class=\""command\"">shell$ #{cmd}</span><br/>""
    res = `#{cmd} 2>&1`
    @out << res.gsub(""\n"", ""<br/>"")
    if $?.exitstatus != 0 then
      error ""Command returned #{$?.exitstatus}""
    end
    res
  end"
JobsController,error,Arg,s,{ JobsController#error arg: s },String,N,,"def error(s)
    @out = """" if not @out
    logger.error ""ERROR: #{s}""
    @out << ""<span class=\""error\"">#{s}</span><br/>""
    @success = false
  end"
JobsController,error,Ret,"",(false or true),false,T,Constraints,"def error(s)
    @out = """" if not @out
    logger.error ""ERROR: #{s}""
    @out << ""<span class=\""error\"">#{s}</span><br/>""
    @success = false
  end"
ListsController,@lists,Var,@lists,Array<List>,Array<List>,E,Constraints,""
ListsController,index,Ret,"",Array<List>,Array<List>,E,Constraints,"def index
    @lists = List.all.sort { |a,b| a.name <=> b.name }
  end"
ListsController,@list,Var,@list,List,List,E,Constraints,""
ListsController,@talks,Var,@talks,Array<Talk>,Array<Talk>,E,Constraints,""
ListsController,@current,Var,@current,(false or true),(false or true),E,Constraints,""
ListsController,show,Ret,"",(Array<String> or String),%any,E,Constraints,"def show
    @list = List.find(params[:id])
    @lists = List.all.sort { |a,b| a.name <=> b.name }
    fix_range params
    case params[:range]
    when :past
      @talks = @list.talks.past.sort { |a,b| [b.start_time.beginning_of_day, a.start_time] <=> [a.start_time.beginning_of_day, b.start_time] }
      @current = false
    when :all
      @talks = @list.talks.sort { |a,b| a.start_time <=> b.start_time }
    else
      @talks = @list.talks.current.sort { |a,b| a.start_time <=> b.start_time }
      @current = true
    end
    respond_to do |format|
      format.html
      format.json
    end
  end"
ListsController,@title,Var,@title,String,String,E,Constraints,""
ListsController,@owners,Var,@owners,Array<User>,Array<User>,E,Constraints,""
ListsController,@posters,Var,@posters,Array<User>,Array<User>,E,Constraints,""
ListsController,@users,Var,@users,ActiveRecord_Relation<User>,Array<User>,E,Constraints,""
ListsController,new,Ret,"",Array<String>,Array<String>,E,Constraints,"def new
    authorize! :create, List
    @list = List.new
    @title = ""Create new list""
    @owners = []
    @posters = []
    @users = User.order(:email)
    render :action => ""edit""
  end"
ListsController,edit,Ret,"",ActiveRecord_Relation<User>,Array<User>,E,Constraints,"def edit
    @list = List.find(params[:id])
    authorize! :edit, @list
    compute_edit_fields
  end"
ListsController,compute_edit_fields,Ret,"",ActiveRecord_Relation<User>,Array<User>,E,Constraints,"def compute_edit_fields
    @title = ""Edit list""
    @owners = @list.owners.sort { |a,b| a.email_and_name <=> b.email_and_name }
    @posters = @list.posters.sort { |a,b| a.email_and_name <=> b.email_and_name }
    @users = User.order(:email)
  end"
ListsController,create,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def create
    authorize! :create, List
    list_params, owners, posters = adjust params
    @list = List.new(list_params)
    @list.owners = owners
    @list.posters = posters

    if @list.save
      redirect_to @list, notice: 'List was successfully created.'
    else
      compute_edit_fields
      render action: ""edit""
    end
  end"
ListsController,update,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def update
    @list = List.find(params[:id])
    authorize! :edit, @list
    list_params, owners, posters = adjust params
    if not (can? :edit_name, @list) then
      list_params.delete :name
    end

    @list.attributes = list_params
    @list.owners = owners
    @list.posters = posters

    if @list.save
      redirect_to @list, notice: 'List was successfully updated.'
    else
      compute_edit_fields
      render action: ""edit""
    end
  end"
ListsController,destroy,Ret,"",String,String,E,Constraints,"def destroy
    @list = List.find(params[:id])
    authorize! :destroy, @list
    @list.destroy

    redirect_to root_path
  end"
ListsController,subscribe,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def subscribe
    l = List.find(params[:id])
    do_subscription(l, params[:do])
    respond_to do |format|
      format.js { render ""shared/_update_badges.js.erb"", :locals => { :subscribable => l } }
      format.html { redirect_to action: ""show"" }
    end
  end"
ListsController,feed,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def feed
    @list = List.find(params[:id])
    @title = @list.name
    @talks = @list.talks
    respond_to do |format|
      format.ics { render :text => (generate_ical @list.talks) }
      format.atom { render ""shared/feed"", :layout => false  }
    end
  end"
ListsController,@subscribers,Var,@subscribers,Array<User>,Array<User>,E,Constraints,""
ListsController,show_subscribers,Ret,"",Array<String>,Array<String>,E,Constraints,"def show_subscribers
    authorize! :site_admin, :all
    @list = List.find(params[:id])
    @subscribers = @list.subscribers.sort { |a,b| a.email_and_name <=> b.email_and_name }
    render ""shared/show_subscribers""
  end"
ListsController,adjust,Arg,params,"([ []: (:list) -> { { ListsController#adjust arg: params }#[] call_ret: ret } ] and [ each_pair: () {({ { ListsController#adjust arg: params }#each_pair block_arg: k }, { { ListsController#adjust arg: params }#each_pair block_arg: v }) -> { { ListsController#adjust arg: params }#each_pair block_ret: block_ret }} -> { { ListsController#adjust arg: params }#each_pair call_ret: ret } ])","Hash<(String or Symbol), %any>",TS,Constraints,"def adjust(params)
    owners = []
    params.each_pair { |k,v|
      next unless k =~ /owner_(\d+)/
      next if v == """"
      owners << User.find(RDL.type_cast(v, ""String""))
    }

    posters = []
    params.each_pair { |k,v|
      next unless k =~ /poster_(\d+)/
      next if v == """"
      posters << User.find(RDL.type_cast(v, ""String""))
    }
    return [params[:list].permit(:name, :short_descr, :long_descr),
      owners, posters]
  end"
ListsController,adjust,Ret,"","[{ name: String }, Array<{ ListsController#adjust array_param: array_param_#<Parser::Source::Map::Collection:0x00007f997b35a388> }>, Array<{ ListsController#adjust array_param: array_param_#<Parser::Source::Map::Collection:0x00007f998374bc28> }>]",Array<User>,P,Constraints,"def adjust(params)
    owners = []
    params.each_pair { |k,v|
      next unless k =~ /owner_(\d+)/
      next if v == """"
      owners << User.find(RDL.type_cast(v, ""String""))
    }

    posters = []
    params.each_pair { |k,v|
      next unless k =~ /poster_(\d+)/
      next if v == """"
      posters << User.find(RDL.type_cast(v, ""String""))
    }
    return [params[:list].permit(:name, :short_descr, :long_descr),
      owners, posters]
  end"
TalksController,@talks,Var,@talks,(ActiveRecord_Relation<Talk> or Array<Talk>),Array<Talk>,P,Heur: is_pluralized_model,""
TalksController,@current,Var,@current,(false or true),(false or true),E,Constraints,""
TalksController,@lists,Var,@lists,Array<List>,Array<List>,E,Constraints,""
TalksController,index,Ret,"",(Array<String> or String),Array<Talk>,T,Constraints,"def index
    fix_range params
    if params[:range] == :past
      @talks = Talk.past.sort { |a,b|
        [b.start_time.beginning_of_day, a.start_time] <=> [a.start_time.beginning_of_day, b.start_time]
      }
      @current = false
    elsif params[:range] == :all
      @talks = Talk.all_recent.sort { |a,b| a.start_time <=> b.start_time }
    else
      @talks = Talk.current.sort { |a,b| a.start_time <=> b.start_time }
      @current = true
    end
    @lists = List.all.sort { |a,b| a.name <=> b.name }
    respond_to do |format|
      format.html
      format.json
    end
end"
TalksController,admin_view,Ret,"",ActiveRecord_Relation<Talk>,Array<Talk>,E,Constraints,"def admin_view
    authorize! :site_admin, :all
    @talks = Talk.all
  end"
TalksController,@talk,Var,@talk,Talk,Talk,E,Constraints,""
TalksController,@title,Var,@title,String,String,E,Constraints,""
TalksController,@posted,Var,@posted,Array<{ TalksController#new array_param: array_param_#<Parser::Source::Map::Collection:0x00007f99807e2ea0> }>,Array<List>,P,Constraints,""
TalksController,new,Ret,"",Array<String>,Array<String>,E,Constraints,"def new
    authorize! :create, Talk
    @talk = Talk.new(:kind => :standard)
    @title = ""Create new talk""
    @posted = []
    @talk.owner = current_user
    if can? :site_admin, :all then
      @lists = List.all.sort { |a,b| a.name <=> b.name }
    else
      @lists = (current_user.owned_lists + current_user.poster_lists).sort { |a,b| a.name <=> b.name }.uniq
    end
    @talk.trigger_watch_email = true
    render :action => ""edit""
  end"
TalksController,@subscription,Var,@subscription,Subscription,Subscription,E,Heur: is_model,""
TalksController,show,Ret,"",(Array<String> or String),Subscription,T,Constraints,"def show
    @talk = Talk.find(params[:id])
    @subscription = @talk.subscription current_user if current_user
    @lists = List.all.sort { |a,b| a.name <=> b.name }
    respond_to do |format|
      format.html
      format.json
    end
  end"
TalksController,create,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def create
    authorize! :create, Talk
    talk_params, lists = adjust params
    @talk = Talk.new(talk_params)
    @talk.lists = lists
    @talk.owner = current_user unless can? :edit_owner, @talk
    if @talk.save
      if params[:talk][:trigger_watch_email] == ""1""
#        @talk.delay.email_watchers(nil)
        redirect_to @talk, :notice => ""Sending talk creation notification to subscribers and watchers...""
      else
        redirect_to @talk
      end
    else
      compute_edit_fields
      render :action => ""edit""
    end
  end"
TalksController,edit,Ret,"",{ TalksController#edit ret: ret },Array<List>,N,,"def edit
    @talk = Talk.find(params[:id])
    authorize! :edit, @talk
    compute_edit_fields
    @talk.trigger_watch_email = false
  end"
TalksController,@talk_old,Var,@talk_old,Talk,Talk,E,Constraints,""
TalksController,update,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def update
    @talk = Talk.find(params[:id])
    @talk_old = @talk.dup
    authorize! :edit, @talk
    talk_params, lists = adjust params
    @talk.lists = lists
    if @talk.update(talk_params)
      if talk_params[:trigger_watch_email] == ""1""
        changes = Set.new
        changes << :title if @talk_old.title != @talk.title
        changes << :speaker if ((@talk_old.speaker != @talk.speaker) || (@talk_old.speaker_url != @talk.speaker_url))
        changes << :venue if ((@talk_old.room != @talk.room) || (@talk_old.building != @talk.building))
        changes << :time if ((@talk_old.start_time != @talk.start_time) || (@talk_old.end_time != @talk.end_time))
        changes << :abstract if (@talk_old.abstract != @talk.abstract)
        changes << :bio if (@talk_old.bio != @talk.bio)
        changes << :reg if (@talk_old.request_reg != @talk.request_reg)
        if changes.empty?
          redirect_to @talk
        else
#          @talk.delay.email_watchers(changes)
          redirect_to @talk, :notice => ""Sending talk update notification to subscribers and watchers...""
        end
      else
        redirect_to @talk
      end
    else
      compute_edit_fields
      render :action => ""edit""
    end
  end"
TalksController,destroy,Ret,"",String,String,E,Constraints,"def destroy
    @talk = Talk.find(params[:id])
    authorize! :edit, @talk
    @talk.destroy
    redirect_to talks_path
  end"
TalksController,subscribe,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def subscribe
    t = Talk.find(params[:id])
    do_subscription(t, params[:do])
    respond_to do |format|
      format.js { render ""shared/_update_badges.js.erb"", :locals => { :subscribable => t } }
      format.html { redirect_to action: ""show"" }
    end
  end"
TalksController,register,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def register
    t = Talk.find(params[:id])
    r = Registration.where(:talk_id => RDL.type_cast(t, ""Integer""), :user_id => current_user)
    raise ""Attempt to register for talk without registration"" if not t.request_reg
    logger.error ""Inconsistency, r is #{r}"" if r.length > 1
    case params[:do]
    when ""register""
      if r.empty?
        r = Registration.new(:talk_id => t.id, :user_id => current_user.id)
        r.save
      end
    when ""unregister""
      r[0].destroy if r[0]
    end
    respond_to do |format|
      format.js { render ""shared/_update_badges.js.erb"", :locals => { :subscribable => t } }
      format.html { redirect_to action: ""show"" }
    end
  end"
TalksController,@regs,Var,@regs,ActiveRecord_Relation<Registration>,Array<Registration>,E,Constraints,""
TalksController,@users,Var,@users,Array<User>,Array<User>,E,Constraints,""
TalksController,show_registrations,Ret,"",Array<String>,(Array<String> or Array<User>),P,Constraints,"def show_registrations
    @talk = Talk.find(params[:id])
    raise ""Attempt to register for talk without registration"" if not @talk.request_reg
    authorize! :edit, @talk
    @regs = @talk.registrations
    @users = User.all.sort { |a,b| a.email_and_name <=> b.email_and_name }
    if params[:csv] == ""true""
      render :show_registrations_csv, :layout => false, :content_type => ""text/csv""
    end
  end"
TalksController,cancel_registration,Ret,"",String,String,E,Constraints,"def cancel_registration
    r = Registration.find(params[:id])
    t = r.talk
    authorize! :edit, r.talk
#    raise ""Attempt to register for talk without registration"" if not t.request_reg
    r.destroy
    redirect_to show_registrations_talk_path(t)
  end"
TalksController,@reg,Var,@reg,Registration,Registration,E,Constraints,""
TalksController,external_register,Ret,"",(Array<String> or Mail::Message),(Array<String> or Mail::Message),E,Constraints,"def external_register
    @talk = Talk.find(params[:id])
    raise ""Attempt to register for talk without registration"" if not @talk.request_reg
    @reg = Registration.new(:talk_id => @talk.id,
                            :user_id => 0,
                            :name => params[:name],
                            :email => params[:email],
                            :organization => params[:organization],
                            :secret => SecureRandom.base64,
                            )
    if @reg.save
      TheMailer.send_external_reg(@reg).deliver_now
    else
      render :action => :show
    end
  end"
TalksController,@success,Var,@success,(false or true),(false or true),E,Constraints,""
TalksController,cancel_external_registration,Ret,"",(false or true),(false or true),E,Constraints,"def cancel_external_registration
    @reg = Registration.find(params[:registration])
    if @reg && (@reg.secret == params[:secret])
      @reg.destroy
      @success = true
      TheMailer.send_cancel_reg(@reg).deliver_now
    else
      @success = false
    end
  end"
TalksController,feed,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def feed
    @talks = Talk.all_recent.sort { |a,b| a.start_time <=> b.start_time }
    @title = t :site_name
    respond_to do |format|
      format.ics { render :text => (generate_ical @talks) }
      format.atom { render ""shared/feed"", :layout => false  }
    end
  end"
TalksController,calendar,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def calendar
    @talk = Talk.find(params[:id])
    respond_to do |format|
      format.ics { render :text => (generate_ical [@talk]) }
    end
  end"
TalksController,show_subscribers,Ret,"",Array<String>,Array<String>,E,Constraints,"def show_subscribers
    authorize! :site_admin, :all
    @talk = Talk.find(params[:id])
    @subscribers = []
    @subscribers += @talk.subscribers
    @subscribers += (@talk.lists.map { |l| l.subscribers }).flatten
    RDL.type_cast(@subscribers, ""Array<User>"").sort! { |a,b| a.email_and_name <=>  b.email_and_name }
    render ""shared/show_subscribers""
  end"
TalksController,feedback,Ret,"",Array<List>,Array<List>,E,Constraints,"def feedback
    @lists = List.all.sort { |a,b| a.name <=> b.name }
  end"
TalksController,receive_feedback,Ret,"",String,String,E,Constraints,"def receive_feedback
    TheMailer.send_feedback(:name => params[:name].truncate(255), :email => params[:email].truncate(255), :subject => params[:subject].truncate(255), :comments => params[:comments].truncate(5000)).deliver_now
    redirect_to root_path, :notice => ""Thank you for your feedback""
  end"
TalksController,adjust,Arg,params,"([ []: (:talk) -> { { TalksController#adjust arg: params }#[] call_ret: ret } ] and [ []: (:temp_date) -> { { TalksController#adjust arg: params }#[] call_ret: ret } ] and [ []: (:temp_date_time) -> { { TalksController#adjust arg: params }#[] call_ret: ret } ] and [ []: (:temp_end_time) -> { { TalksController#adjust arg: params }#[] call_ret: ret } ] and [ []: (:temp_start_time) -> { { TalksController#adjust arg: params }#[] call_ret: ret } ] and [ each_pair: () {({ { TalksController#adjust arg: params }#each_pair block_arg: k }, { { TalksController#adjust arg: params }#each_pair block_arg: v }) -> { { TalksController#adjust arg: params }#each_pair block_ret: block_ret }} -> { { TalksController#adjust arg: params }#each_pair call_ret: ret } ] and [ require: (:talk) -> { { TalksController#adjust arg: params }#require call_ret: ret } ])","Hash<(String or Symbol), %any>",TS,Constraints,"def adjust(params)
    if params[:temp_date_time] != """" then
      # TODO: handle parsing errors here
      if (params[:temp_date_time] =~ /(.*) from (.*) to (.*)/) || (params[:temp_date_time] =~ /(.*) from (.*)\s*-\s*(.*)/) then
        params[:talk][:start_time] = Chronic.parse(""#{$1} at #{$2}"")
        params[:talk][:end_time] = Chronic.parse(""#{$1} at #{$3}"")
      else
        params[:talk][:start_time] = params[:talk][:end_time] = nil
      end
    else
      params[:talk][:start_time] = Chronic.parse(""#{params[:temp_date]} #{params[:temp_start_time]}"")
      params[:talk][:end_time] = Chronic.parse(""#{params[:temp_date]} #{params[:temp_end_time]}"")
#      errors.add(nil, ""Malformed date or time"") if not (params[:talk][:start_time] && params[:talk][:end_time])
    end

    lists = []
    params.each_pair { |k,v|
      next unless k =~ /posted_(\d+)/
      next if v == """"
      l = List.find RDL.type_cast(v, ""String"")
      next unless can? :add_talk, l
      lists << l
    }

    return [params.require(:talk).permit(:title, :speaker, :speaker_affiliation,
      :speaker_url, :room, :building_id, :kind, :request_reg,
      :trigger_watch_email, :owner_id, :abstract, :bio,
      :reg_info, :start_time, :end_time), lists]
#    params.require(:talk).permit!
  end"
TalksController,adjust,Ret,"","[{  }, Array<{ TalksController#adjust array_param: array_param_#<Parser::Source::Map::Collection:0x00007f9982aada20> }>]",Array<List>,P,Constraints,"def adjust(params)
    if params[:temp_date_time] != """" then
      # TODO: handle parsing errors here
      if (params[:temp_date_time] =~ /(.*) from (.*) to (.*)/) || (params[:temp_date_time] =~ /(.*) from (.*)\s*-\s*(.*)/) then
        params[:talk][:start_time] = Chronic.parse(""#{$1} at #{$2}"")
        params[:talk][:end_time] = Chronic.parse(""#{$1} at #{$3}"")
      else
        params[:talk][:start_time] = params[:talk][:end_time] = nil
      end
    else
      params[:talk][:start_time] = Chronic.parse(""#{params[:temp_date]} #{params[:temp_start_time]}"")
      params[:talk][:end_time] = Chronic.parse(""#{params[:temp_date]} #{params[:temp_end_time]}"")
#      errors.add(nil, ""Malformed date or time"") if not (params[:talk][:start_time] && params[:talk][:end_time])
    end

    lists = []
    params.each_pair { |k,v|
      next unless k =~ /posted_(\d+)/
      next if v == """"
      l = List.find RDL.type_cast(v, ""String"")
      next unless can? :add_talk, l
      lists << l
    }

    return [params.require(:talk).permit(:title, :speaker, :speaker_affiliation,
      :speaker_url, :room, :building_id, :kind, :request_reg,
      :trigger_watch_email, :owner_id, :abstract, :bio,
      :reg_info, :start_time, :end_time), lists]
#    params.require(:talk).permit!
  end"
TalksController,@date,Var,@date,Array<List>,String,T,Twin,""
TalksController,@start_time,Var,@start_time,String,String,E,Twin,""
TalksController,@end_time,Var,@end_time,String,String,E,Twin,""
TalksController,compute_edit_fields,Ret,"",Array<List>,Array<List>,E,Constraints,"def compute_edit_fields
    @title = ""Edit talk""
    if @talk.start_time && @talk.end_time
      @date = @talk.start_time.strftime(""%m/%d/%Y"")
      @start_time = @talk.start_time.strftime(""%l:%M %P"").lstrip
      @end_time = @talk.end_time.strftime(""%l:%M %P"").lstrip
    end
    @posted = @talk.lists
    if can? :site_admin, :all then
      @lists = List.all.sort { |a,b| a.name <=> b.name }
    else
      @lists = (current_user.owned_lists + current_user.poster_lists).sort { |a,b| a.name <=> b.name }.uniq
    end
  end"
UsersController,@users,Var,@users,Array<User>,Array<User>,E,Constraints,""
UsersController,index,Ret,"",Array<User>,Array<User>,E,Constraints,"def index
    authorize! :site_admin, :all
    @users = User.all.sort { |a,b| a.email <=> b.email }
  end"
UsersController,@user,Var,@user,User,User,E,Constraints,""
UsersController,@current,Var,@current,(false or true),(false or true),E,Constraints,""
UsersController,@list_subscriptions,Var,@list_subscriptions,Hash,"Hash<List, Symbol>",P,Constraints,""
UsersController,@your_lists,Var,@your_lists,Array<User>,Array<List>,P,Twin,""
UsersController,@lists,Var,@lists,Array<List>,Array<List>,E,Constraints,""
UsersController,@talk_subscriptions,Var,@talk_subscriptions,Hash,"Hash<Talk, (String or Symbol)>",P,Twin,""
UsersController,@talks,Var,@talks,Array<(Talk or { User#subscribed_talks hash_param_key: hash_param_key_#<Parser::Source::Map::Collection:0x00007f997b1dcd08> })>,Array<Talk>,P,Constraints,""
UsersController,show,Ret,"",Array<Talk>,Array<Talk>,E,Constraints,"def show
    @user = User.find(params[:id])
    authorize! :edit, @user
    fix_range params
    if params[:range] == :past
      @current = false
    else
      @current = true
    end
    @list_subscriptions = Hash[current_user.subscribed_lists]
    @your_lists = (current_user.owned_lists + current_user.poster_lists + @list_subscriptions.keys).sort { |a,b| a.name <=> b.name }.uniq
    @lists = List.all.sort { |a,b| a.name <=> b.name }
    @talk_subscriptions = current_user.subscribed_talks(params[:range])
    if @current then
      @talks = current_user.owned_talks.current
    else
      @talks = current_user.owned_talks.past
    end
    @talks += RDL.type_cast(@talk_subscriptions.keys, ""Array<Talk>"")
    @talks.uniq!
    if params[:range] == :past
      @talks.sort! { |a,b| [b.start_time.beginning_of_day, a.start_time] <=> [a.start_time.beginning_of_day, b.start_time] }
    else
      @talks.sort! { |a,b| a.start_time <=> b.start_time }
    end
  end"
UsersController,edit,Ret,"",Array<String>,%any,E,Twin,"def edit
    @user = User.find(params[:id])
    authorize! :edit, @user
  end"
UsersController,update,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def update
    @user = User.find(params[:id])
    authorize! :edit, @user
    up = user_params
    if up[:password].blank?
      up.delete :password
      up.delete :password_confirmation
    end
    unless can? :site_admin, :all
      up.delete :perm_site_admin
      up.delete :perm_create_talk
    end
    if @user.update(up)
      redirect_to @user
    else
      render :action => ""edit""
    end
  end"
UsersController,destroy,Ret,"",String,String,E,Constraints,"def destroy
    @user = User.find(params[:id])
    authorize! :site_admin, :all
    @user.destroy
    redirect_to users_path
  end"
UsersController,@title,Var,@title,String,String,E,Constraints,""
UsersController,feed,Ret,"",(Array<String> or String),(Array<String> or String),E,Constraints,"def feed
    user = User.find(params[:id])
    @title = ""Your Talks""
    @talks = user.subscribed_talks(:all, [""kind_subscriber"", ""kind_subscriber_through""]).keys
    respond_to do |format|
      if params[:key] == user.ical_secret
        format.ics { render :text => (generate_ical @talks) }
        format.atom { render ""shared/feed"", :layout => false  }
      else
        format.ics { render :nothing => true, :status => :forbidden }
        format.atom { render :nothing => true, :status => :forbidden }
      end
    end
  end"
UsersController,reset_ical_secret,Ret,"",String,String,E,Constraints,"def reset_ical_secret
    @user = User.find(params[:id])
    authorize! :edit, @user
    @user.update_attribute(:ical_secret, nil)
    redirect_to users_path, :notice => ""ical secret reset for #{@user.email}""
  end"
UsersController,generate_ical_secret,Ret,"",(false or true),true,T,Constraints,"def generate_ical_secret
    if current_user && (current_user.ical_secret == nil || current_user.ical_secret == """") then
      current_user.update_attribute(:ical_secret, SecureRandom.base64)
    end
    true
  end"
TheMailer,@talks,Var,@talks,(ActiveRecord_Relation<Talk> or Array<Talk>),Array<Talk>,P,Heur: is_pluralized_model,""
TheMailer,@subj,Var,@subj,String,String,E,Constraints,""
TheMailer,send_talks,Arg,user,User,User,E,Heur: is_model,"def send_talks(user, talks, subj)
    @talks = talks.sort { |a,b| a.start_time <=> b.start_time }
    @subj = subj
    mail :to => ""#{user.name} <#{user.email}>"",
         :subject => ""[Talks] #{@subj}""
  end"
TheMailer,send_talks,Arg,talks,(ActiveRecord_Relation<Talk> or Array<Talk>),Array<Talk>,P,Heur: is_pluralized_model,"def send_talks(user, talks, subj)
    @talks = talks.sort { |a,b| a.start_time <=> b.start_time }
    @subj = subj
    mail :to => ""#{user.name} <#{user.email}>"",
         :subject => ""[Talks] #{@subj}""
  end"
TheMailer,send_talks,Arg,subj,String,String,E,Constraints,"def send_talks(user, talks, subj)
    @talks = talks.sort { |a,b| a.start_time <=> b.start_time }
    @subj = subj
    mail :to => ""#{user.name} <#{user.email}>"",
         :subject => ""[Talks] #{@subj}""
  end"
TheMailer,send_talks,Ret,"",ActionMailer::MessageDelivery,Mail::Message,T,Constraints,"def send_talks(user, talks, subj)
    @talks = talks.sort { |a,b| a.start_time <=> b.start_time }
    @subj = subj
    mail :to => ""#{user.name} <#{user.email}>"",
         :subject => ""[Talks] #{@subj}""
  end"
TheMailer,@reg,Var,@reg,Registration,Registration,E,Constraints,""
TheMailer,@talk,Var,@talk,Talk,Talk,E,Constraints,""
TheMailer,send_external_reg,Arg,reg,Registration,Registration,E,Heur: struct_to_nominal,"def send_external_reg(reg)
    @reg = reg
    @talk = reg.talk

    mail :to => ""#{@reg.name} <#{@reg.email}>"",
         :subject => ""[Talks] Registration confirmation""
  end"
TheMailer,send_external_reg,Ret,"",ActionMailer::MessageDelivery,Mail::Message,T,Constraints,"def send_external_reg(reg)
    @reg = reg
    @talk = reg.talk

    mail :to => ""#{@reg.name} <#{@reg.email}>"",
         :subject => ""[Talks] Registration confirmation""
  end"
TheMailer,@user,Var,@user,User,User,E,Constraints,""
TheMailer,@changes,Var,@changes,(ActiveRecord_Relation<Talk> or Array<Talk>),Set<Symbol>,T,Constraints,""
TheMailer,send_talk_change,Arg,user,User,User,E,Constraints,"def send_talk_change(user, talk, changes)
    @user = user
    @talk = talk
    @changes = changes
    if @changes
      @subj = ""[Talks] Talk update: #{@talk.title}""
    else
      @subj = ""[Talks] New talk posted: #{@talk.title}""
    end

    mail :to => ""#{@user.name} <#{@user.email}>"",
         :subject => @subj
  end"
TheMailer,send_talk_change,Arg,talk,Talk,Talk,E,Constraints,"def send_talk_change(user, talk, changes)
    @user = user
    @talk = talk
    @changes = changes
    if @changes
      @subj = ""[Talks] Talk update: #{@talk.title}""
    else
      @subj = ""[Talks] New talk posted: #{@talk.title}""
    end

    mail :to => ""#{@user.name} <#{@user.email}>"",
         :subject => @subj
  end"
TheMailer,send_talk_change,Arg,changes,(ActiveRecord_Relation<Talk> or Array<Talk>),Set<(:abstract or :bio or :reg or :speaker or :time or :title or :venue)>,T,Twin,"def send_talk_change(user, talk, changes)
    @user = user
    @talk = talk
    @changes = changes
    if @changes
      @subj = ""[Talks] Talk update: #{@talk.title}""
    else
      @subj = ""[Talks] New talk posted: #{@talk.title}""
    end

    mail :to => ""#{@user.name} <#{@user.email}>"",
         :subject => @subj
  end"
TheMailer,send_talk_change,Ret,"",ActionMailer::MessageDelivery,Mail::Message,T,Constraints,"def send_talk_change(user, talk, changes)
    @user = user
    @talk = talk
    @changes = changes
    if @changes
      @subj = ""[Talks] Talk update: #{@talk.title}""
    else
      @subj = ""[Talks] New talk posted: #{@talk.title}""
    end

    mail :to => ""#{@user.name} <#{@user.email}>"",
         :subject => @subj
  end"
TheMailer,@comments,Var,@comments,String,String,E,Constraints,""
TheMailer,send_feedback,Arg,h,"{ comments: String, subject: String, name: { { TheMailer#send_feedback arg: h }#[] call_ret: ret }, email: { { TheMailer#send_feedback arg: h }#[] call_ret: ret } }","Hash<Symbol, String>",P,Heur: hash_access,"def send_feedback(h)
    @comments = h[:comments]
    mail :to => ""Talks <talks@cs.umd.edu>"",
         :subject => h[:subject],
         :from => ""#{h[:name]} <#{h[:email]}>""
  end"
TheMailer,send_feedback,Ret,"",ActionMailer::MessageDelivery,Mail::Message,T,Constraints,"def send_feedback(h)
    @comments = h[:comments]
    mail :to => ""Talks <talks@cs.umd.edu>"",
         :subject => h[:subject],
         :from => ""#{h[:name]} <#{h[:email]}>""
  end"
TheMailer,@message,Var,@message,String,String,E,Twin,""
TheMailer,send_admin_message,Arg,u,(Gem::Specification or Registration or User),User,T,Heur: struct_to_nominal,"def send_admin_message(u, h)
    @message = h[:message]
    mail :to => ""#{u.name} <#{u.email}>"",
         :subject => h[:subject]
  end"
TheMailer,send_admin_message,Arg,h,"{ message: { { TheMailer#send_admin_message arg: h }#[] call_ret: ret }, subject: String }","Hash<Symbol, String>",P,Heur: hash_access,"def send_admin_message(u, h)
    @message = h[:message]
    mail :to => ""#{u.name} <#{u.email}>"",
         :subject => h[:subject]
  end"
TheMailer,send_admin_message,Ret,"",ActionMailer::MessageDelivery,Mail::Message,T,Constraints,"def send_admin_message(u, h)
    @message = h[:message]
    mail :to => ""#{u.name} <#{u.email}>"",
         :subject => h[:subject]
  end"
ApplicationHelper,join_with_and,Arg,a,([ []: (Number) -> { { ApplicationHelper#join_with_and arg: a }#[] call_ret: ret } ] and [ []: (Range<Number>) -> { { ApplicationHelper#join_with_and arg: a }#[] call_ret: ret } ] and [ length: () -> { { ApplicationHelper#join_with_and arg: a }#length call_ret: ret } ]),Array<String>,TS,Constraints,"def join_with_and(a)
    return """" if a.length == 0
    return a[0] if a.length == 1
    return ""#{a[0]} and #{a[1]}"" if a.length == 2
    return ""#{a[0..-2].join "",""}, and #{a[-1]}""
  end"
ApplicationHelper,join_with_and,Ret,"",String,String,E,Constraints,"def join_with_and(a)
    return """" if a.length == 0
    return a[0] if a.length == 1
    return ""#{a[0]} and #{a[1]}"" if a.length == 2
    return ""#{a[0..-2].join "",""}, and #{a[-1]}""
  end"
TalksHelper,@out,Var,@out,String,String,E,Constraints,""
TalksHelper,render_speaker,Arg,talk,Talk,Talk,E,Heur: is_model,"def render_speaker(talk)
    if talk.speaker.empty?
      @out = ""No speaker yet""
    else
      @out = talk.speaker
    end
    unless talk.speaker_affiliation.empty?
      @out += "" - #{talk.speaker_affiliation}""
    end
    unless talk.speaker_url.empty?
      @out = link_to @out, talk.speaker_url
    end
    return @out.sanitize
  end"
TalksHelper,render_speaker,Ret,"",String,String,E,Constraints,"def render_speaker(talk)
    if talk.speaker.empty?
      @out = ""No speaker yet""
    else
      @out = talk.speaker
    end
    unless talk.speaker_affiliation.empty?
      @out += "" - #{talk.speaker_affiliation}""
    end
    unless talk.speaker_url.empty?
      @out = link_to @out, talk.speaker_url
    end
    return @out.sanitize
  end"
TalksHelper,render_venue,Arg,talk,Talk,Talk,E,Heur: is_model,"def render_venue(talk)
    return ""<i>No venue yet</i>"".sanitize unless (talk.room || talk.building)

    if talk.building && (not talk.building.name.empty?)
      @out = ""#{talk.room} #{talk.building.name} (#{talk.building.abbrv})""
    elsif talk.building
      @out = ""#{talk.room} #{talk.building.abbrv}""
    else
      @out = talk.room
    end
    if talk.building && talk.building.url && (not talk.building.url.empty?)
      @out = link_to @out, talk.building.url
    end
    return @out.sanitize
  end"
TalksHelper,render_venue,Ret,"",String,String,E,Constraints,"def render_venue(talk)
    return ""<i>No venue yet</i>"".sanitize unless (talk.room || talk.building)

    if talk.building && (not talk.building.name.empty?)
      @out = ""#{talk.room} #{talk.building.name} (#{talk.building.abbrv})""
    elsif talk.building
      @out = ""#{talk.room} #{talk.building.abbrv}""
    else
      @out = talk.room
    end
    if talk.building && talk.building.url && (not talk.building.url.empty?)
      @out = link_to @out, talk.building.url
    end
    return @out.sanitize
  end"
TalksHelper,render_time,Arg,talk,Talk,Talk,E,Heur: is_model,"def render_time(talk)
    if talk.start_time && talk.end_time
      @out = (talk.start_time.strftime ""%A, %B %-d, %Y, "") + (talk.start_time.strftime(""%l:%M"").lstrip)
      if ((talk.start_time.hour < 12) == (talk.end_time.hour < 12)) # both am or both pm
        @out += ""-"" + (talk.end_time.strftime(""%l:%M %P"").lstrip)
      else
        @out += (talk.start_time.strftime "" %P-"") + (talk.end_time.strftime(""%l:%M %P"").lstrip)
      end
    else
      @out = ""(Time not yet available)""
    end
    return @out.sanitize
  end"
TalksHelper,render_time,Ret,"",String,String,E,Twin,"def render_time(talk)
    if talk.start_time && talk.end_time
      @out = (talk.start_time.strftime ""%A, %B %-d, %Y, "") + (talk.start_time.strftime(""%l:%M"").lstrip)
      if ((talk.start_time.hour < 12) == (talk.end_time.hour < 12)) # both am or both pm
        @out += ""-"" + (talk.end_time.strftime(""%l:%M %P"").lstrip)
      else
        @out += (talk.start_time.strftime "" %P-"") + (talk.end_time.strftime(""%l:%M %P"").lstrip)
      end
    else
      @out = ""(Time not yet available)""
    end
    return @out.sanitize
  end"
TalksHelper,render_lists,Arg,talk,Talk,Talk,E,Heur: is_model,"def render_lists(talk)
    return (talk.lists
              .sort { |a,b| a.name <=> b.name }
              .map { |l| link_to l.name, list_url(l) }
              .join ""&nbsp;&sdot;&nbsp;"").sanitize
  end"
TalksHelper,render_lists,Ret,"",String,String,E,Constraints,"def render_lists(talk)
    return (talk.lists
              .sort { |a,b| a.name <=> b.name }
              .map { |l| link_to l.name, list_url(l) }
              .join ""&nbsp;&sdot;&nbsp;"").sanitize
  end"
TalksHelper,render_array_of_lists,Arg,lists,(ActiveRecord_Relation<List> or Array<List>),Array<List>,P,Heur: is_pluralized_model,"def render_array_of_lists(lists)
    return (lists
              .sort { |a,b| a.name <=> b.name }
              .map { |l| link_to l.name, list_url(l) }
              .join ""&nbsp;&sdot;&nbsp;"").sanitize
  end"
TalksHelper,render_array_of_lists,Ret,"",String,String,E,Constraints,"def render_array_of_lists(lists)
    return (lists
              .sort { |a,b| a.name <=> b.name }
              .map { |l| link_to l.name, list_url(l) }
              .join ""&nbsp;&sdot;&nbsp;"").sanitize
  end"
TalksHelper,organize_talks,Arg,talks,[ each: () {({ { TalksHelper#organize_talks arg: talks }#each block_arg: t }) -> { { TalksHelper#organize_talks arg: talks }#each block_ret: block_ret }} -> { { TalksHelper#organize_talks arg: talks }#each call_ret: ret } ],Array<Talk>,TS,Constraints,"def organize_talks(talks)
    h = Hash.new
    h[:past] = []
    h[:today] = []
    h[:later_this_week] = []
    (0..6).each { |wday| h[:later_this_week][wday] = [] }
    h[:next_week] = []
    (0..6).each { |wday| h[:next_week][wday] = [] }
    h[:beyond] = []

    h[:now] = Time.now

    the_past = (h[:now] - 1.day).end_of_day
    today = h[:now].beginning_of_day..h[:now].end_of_day
    later_this_week = (h[:now].beginning_of_day + 1.day)..((h[:now] + 1.day).end_of_week - 1.day)
    next_week = ((h[:now] + 1.day).beginning_of_week + 6.day)..((h[:now] + 1.day).end_of_week + 6.day)
    beyond = (h[:now] + 1.day).beginning_of_week + 13.day

    talks.each do |t|
      if t.start_time <= the_past
        h[:past] << t
      elsif today.cover? t.start_time
        h[:today] << t
      elsif later_this_week.cover? t.start_time
        h[:later_this_week][t.start_time.wday] << t
      elsif next_week.cover? t.start_time
        h[:next_week][t.start_time.wday] << t
      else
        h[:beyond] << t
      end
    end

    h[:past].sort! { |a,b| a.start_time <=> b.start_time }
    h[:today].sort! { |a,b| a.start_time <=> b.start_time }
    h[:later_this_week].each { |ts| ts.sort! { |a,b| a.start_time <=> b.start_time } }
    h[:next_week].each { |ts| ts.sort! { |a,b| a.start_time <=> b.start_time } }
    h[:beyond].sort! { |a,b| a.start_time <=> b.start_time }

    return h
  end"
TalksHelper,organize_talks,Ret,"","{ past: Array<{ TalksHelper#organize_talks array_param: array_param_#<Parser::Source::Map::Collection:0x00007f99841cb770> }>, today: Array<{ TalksHelper#organize_talks array_param: array_param_#<Parser::Source::Map::Collection:0x00007f99841c8728> }>, later_this_week: Array<{ TalksHelper#organize_talks array_param: array_param_#<Parser::Source::Map::Collection:0x00007f99841d10f8> }>, next_week: Array<{ TalksHelper#organize_talks array_param: array_param_#<Parser::Source::Map::Collection:0x00007f99841f2140> }>, beyond: Array<{ TalksHelper#organize_talks array_param: array_param_#<Parser::Source::Map::Collection:0x00007f998420bde8> }>, now: Time }","Hash<(:beyond or :later_this_week or :next_week or :now or :past or :today), (Array<Array<Talk>> or Array<Talk> or Time)>",P,Constraints,"def organize_talks(talks)
    h = Hash.new
    h[:past] = []
    h[:today] = []
    h[:later_this_week] = []
    (0..6).each { |wday| h[:later_this_week][wday] = [] }
    h[:next_week] = []
    (0..6).each { |wday| h[:next_week][wday] = [] }
    h[:beyond] = []

    h[:now] = Time.now

    the_past = (h[:now] - 1.day).end_of_day
    today = h[:now].beginning_of_day..h[:now].end_of_day
    later_this_week = (h[:now].beginning_of_day + 1.day)..((h[:now] + 1.day).end_of_week - 1.day)
    next_week = ((h[:now] + 1.day).beginning_of_week + 6.day)..((h[:now] + 1.day).end_of_week + 6.day)
    beyond = (h[:now] + 1.day).beginning_of_week + 13.day

    talks.each do |t|
      if t.start_time <= the_past
        h[:past] << t
      elsif today.cover? t.start_time
        h[:today] << t
      elsif later_this_week.cover? t.start_time
        h[:later_this_week][t.start_time.wday] << t
      elsif next_week.cover? t.start_time
        h[:next_week][t.start_time.wday] << t
      else
        h[:beyond] << t
      end
    end

    h[:past].sort! { |a,b| a.start_time <=> b.start_time }
    h[:today].sort! { |a,b| a.start_time <=> b.start_time }
    h[:later_this_week].each { |ts| ts.sort! { |a,b| a.start_time <=> b.start_time } }
    h[:next_week].each { |ts| ts.sort! { |a,b| a.start_time <=> b.start_time } }
    h[:beyond].sort! { |a,b| a.start_time <=> b.start_time }

    return h
  end"
TalksHelper,format_day,Arg,time,(ActiveSupport::TimeWithZone or Date or String or TZInfo::Timezone or Time),(ActiveSupport::TimeWithZone or Date),T,Heur: struct_to_nominal,"def format_day(time)
    time.strftime(""%A, %B %-d, %Y"")
  end"
TalksHelper,format_day,Ret,"",String,String,E,Constraints,"def format_day(time)
    time.strftime(""%A, %B %-d, %Y"")
  end"
Total # E:,140
Total # P:,22
Total # T:,22
Total # TS:,7
Total # N:,5
Total # return types:,110
Total # arg types:,39
Total # var types:,47
Total # individual types:,196
